# Lab 2
[Fork](https://docs.github.com/en/get-started/quickstart/fork-a-repo) this repo and clone it to your machine to get started!

## Team Members
- Dylan Gatua

## Lab Question Answers
1. When 50% packet loss is added to the local environment, the reliability of UDP will decrease significantly. This is because UDP is a connectionless protocol that does not guarantee the delivery of packets. With 50% packet loss, half of the packets are lost, which may cause delays or even failure in the communication process. UDP does not have any mechanism for retransmission, error recovery, or flow control, so the lost packets will not be recovered, and the data transmission may be incomplete or incorrect.

2. The reliability of TCP is generally more robust than UDP since TCP is a reliable protocol that provides mechanisms for error detection, recovery, and flow control. When 50% packet loss is introduced, TCP's reliability may decrease somewhat, but the impact will be less severe than UDP. TCP uses a sequence number to track packets, and if a packet is lost, TCP will detect the loss and retransmit the packet. This mechanism ensures that all packets are delivered correctly and in order, which results in better reliability.

3. The speed of the TCP response may decrease when 50% packet loss is added to the local environment. This may happen because TCP uses flow control mechanisms to ensure that the receiver can handle the data at the same rate as the sender is transmitting it. When packets are lost, TCP detects the loss and reduces the transmission rate, causing the sender to slow down. As a result, the speed of the TCP response may be slower due to the additional retransmissions and reduced transmission rate. Additionally, the network congestion caused by the lost packets may also contribute to slower response times.


1. `argc` is the number of command line arguments passed to the program, including the program name itself, and `*argv[]` is an array of strings containing the arguments. 
2. A UNIX file descriptor is an integer value that identifies an open file or I/O stream, and the file descriptor table is a data structure used by the operating system to keep track of all open file descriptors for a process. 
3. A struct is a composite data type in C that groups together related data items of different types under a single name. The `sockaddr_in` struct is a structure that contains an internet address, defined in the `netinet/in.h` header file, and is used to specify the IP address and port number of a socket when binding it to a local address. 
4. `socket()` is a system call that creates a new communication endpoint, returning a file descriptor for the socket. Its input parameters are the address family (e.g., AF_INET for IPv4), the socket type (e.g., SOCK_STREAM for a TCP socket), and the protocol (usually 0, which allows the operating system to choose the appropriate protocol). Its return value is the file descriptor for the new socket. 
5. `bind()` is a system call that assigns a local address to a socket, allowing it to receive incoming connections. Its input parameters are the socket file descriptor, a pointer to a `sockaddr` struct containing the local address to bind to (cast to a `struct sockaddr *`), and the size of the address struct. `listen()` is a system call that places the socket in a passive listening mode, waiting for incoming connection requests. Its input parameters are the socket file descriptor and the size of the backlog queue (i.e., the maximum number of pending connections that can be queued up). 
6. The `while(1)` loop causes the server to continuously listen for incoming connections and handle them as they arrive. Without this loop, the program would terminate after handling a single connection. If there are multiple simultaneous connections to handle, the server could become overwhelmed and unable to respond to all of them in a timely manner, leading to dropped connections and lost data. 
7. `fork()` is a system call that creates a new process by duplicating the calling process. In a server program, `fork()` can be used to create child processes to handle incoming connections, allowing the parent process to continue listening for new connections. Each child process would have its own copy of the file descriptors, including the socket file descriptor returned by `accept()`, allowing it to handle a single connection independently of the parent process. This approach is called the "fork and forget" model, and it is commonly used in server programs to handle multiple concurrent connections. 
8. A system call is a request made by a user program to the operating system kernel to perform a privileged operation, such as accessing hardware devices, managing memory, or creating network connections. System calls provide a standardized interface between user programs and the underlying hardware and operating system, allowing programs to be written in a portable and hardware-independent manner. When a system call is invoked, the user program is suspended, and control is transferred to the kernel, which performs the requested operation on behalf of the program. After the operation is complete, control is returned to the program, which can continue execution.
